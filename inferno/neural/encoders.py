from abc import ABC, abstractmethod, abstractproperty

import torch
import torch.nn as nn


class AbstractEncoder(nn.Module, ABC):
    """Abstract class for representing a population of input neurons (taking some specified input and returning a spike train).

    .. note::
        Objects which are instances of `AbstractEncoder` are iterable.
    """

    def __init__(self):
        nn.Module.__init__(self)

    @abstractproperty
    def ready(self) -> bool:
        """If the encoder is able to generate a spiking output.

        Raises:
            NotImplementedError: :py:attr:`ready` is abstract and must be implemented by the subclass.

        Returns:
            bool: if the encoder is currently able to generate a spiking output.
        """
        raise NotImplementedError(f"'AbstractEncoder.ready' is abstract, {type(self).__name__} must implement the 'ready' property")

    @abstractmethod
    def clear(self, **kwargs) -> None:
        """Reinitializes the encoder state.

        Raises:
            NotImplementedError: :py:meth:`clear` is abstract and must be implemented by the subclass.
        """
        raise NotImplementedError(f"'AbstractEncoder.clear()' is abstract, {type(self).__name__} must implement the 'clear' method")

    @abstractmethod
    def load(self, *inputs, **kwargs) -> None:
        """Loads data into encoder for conversion to a spike train.

        Raises:
            NotImplementedError: :py:meth:`load` is abstract and must be implemented by the subclass.
        """
        raise NotImplementedError(f"'AbstractEncoder.load()' is abstract, {type(self).__name__} must implement the 'load' method")

    @abstractmethod
    def forward(self) -> torch.Tensor | None:
        """Generates spikes for next timestep, if ready.

        Raises:
            NotImplementedError: :py:meth:`forward` is abstract and must be implemented by the subclass.

        Returns:
            torch.Tensor | None: tensor of spikes for this timestep (if :py:attr:`ready` is `True`), otherwise `None`.
        """
        raise NotImplementedError(f"'AbstractEncoder.forward()' is abstract, {type(self).__name__} must implement the 'forward' method")

    def __iter__(self):
        """Magic method for iteration, returns iterable.

        Returns:
            AbstractEncoder: current encoder instance.
        """
        return self

    def __next__(self):
        """Magic method for iteration, returns next item.

        Executes :py:meth:`__call__` so long as :py:attr:`ready` returns `True`.

        Raises:
            StopIteration: encoder is no longer ready.

        Returns:
            torch.Tensor: tensor of spikes for this timestep (if :py:attr:`ready` is `True`).
        """
        if self.ready:
            return self()
        else:
            raise StopIteration


class PassthroughEncoder(AbstractEncoder):
    """Models input neurons by directly passing through a tensor of spikes.

    This encoder takes an :py:class:`nn.Tensor` of spikes returns slices of it along the time axis.

    .. note::
        Internally, the data tensor is stored with the shape :math:`B \\times (N_1 \\times \\cdots) \\times T`,
        where :math:`B` is the number of batches, :math:`T` is the number of time steps, and :math:`N_1, \\ldots` are
        the dimensions of the data. Tensor output at each time step is of the shape :math:`B \\times (N_1 \\times \\cdots)`.
    """
    def __init__(self):
        # call superclass constructor
        AbstractEncoder.__init__(self)

        # register data buffer
        self.register_buffer('data', None)

    @property
    def ready(self) -> bool:
        """If the encoder is able to generate a spiking output.

        Returns:
            bool: if the encoder is currently able to generate a spiking output.
        """
        if self.data is not None:
            if not self.index >= self.data.shape[-1]:
                return True
            else:
                return False
        else:
            return False

    def clear(self, **kwargs) -> None:
        """Reinitializes the encoder state, preparing it for another :py:meth:`load` call.
        """
        if self.data is not None:
            del self.data
            del self.index
            self.register_buffer('data', None)

    def load(
        self,
        inputs: torch.Tensor,
        batch_dim: int | None = None,
        time_dim: int | None = None
    ) -> None:
        """Loads data into encoder which will return slices at each time step.

        Args:
            inputs (torch.Tensor): tensor containing the spikes which should be generated by the encoder.
            batch_dim (int | None, optional): dimension of the input tensor which should be treated as the axis along the batch, if `None` this axis is created. Defaults to `None`.
            time_dim (int | None, optional): dimension of the input tensor which should be treated as the axis along which this will be sliced at each timestep, if `None` this axis is created. Defaults to `None`. Defaults to `None`.
        """
        # clear existing state
        self.clear()

        # set data as empty tensor
        self.data = torch.empty_like(inputs, requires_grad=False)

        # set pointer index
        self.index = 0

        # copy inputs into data
        self.data.copy_(inputs)

        # reshape data according to provided batch dimension
        if batch_dim is None:
            self.data.unsqueeze_(0)
        else:
            batch_dim = int(batch_dim) % len(tuple(self.data.shape))
            self.data = torch.movedim(self.data, batch_dim, 0)

        # reshape data according to provided time dimension
        if time_dim is None:
            self.data.unsqueeze_(-1)
        else:
            time_dim = int(time_dim) % len(tuple(self.data.shape))
            self.data = torch.movedim(self.data, time_dim, -1)

    def forward(self) -> torch.Tensor | None:
        """Generates spikes for next timestep, if ready.

        This is done by returning a slice of the loaded :py:class:`nn.Tensor` along the axis defined by the specified time dimension. It will return the :math:`i^\\text{th}`
        slice along this dimension where :math:`i` is the number of times the encoder has previously been called since the last time :py:meth:`load` has been called.

        Returns:
            torch.Tensor | None: tensor of spikes for this timestep (if :py:attr:`ready` is `True`), otherwise `None`.
        """
        if self.ready:
            self.index += 1
            return self.data.select(-1, self.index - 1)


class HomogeneousPoissonEncoder(AbstractEncoder):
    """Models input neurons using a homogeneous Poisson point process.

    This uses the following approximation to compute if a spike should be generated for a given timestep.

    .. math::
        S_\\text{out} =
        \\begin{cases}
            x\\sim\\mathcal{U}(0, 1) < \\frac{f\\Delta t}{1000} & 1\\\\
            x\\sim\\mathcal{U}(0, 1) \\geq \\frac{f\\Delta t}{1000} & 0
        \\end{cases}

    Where :math:`f` is the expected frequency of spikes in :math:`Hz`, and :math:`\\Delta t` is the length of the simulation timestep in :math:`ms`.
    """
    def __init__(self):
        # call superclass constructor
        AbstractEncoder.__init__(self)

        # register data buffer
        self.register_buffer('data', None)

    @property
    def ready(self) -> bool:
        """If the encoder is able to generate a spiking output.

        Returns:
            bool: if the encoder is currently able to generate a spiking output.
        """
        if self.data is not None:
            if self.index < self.limit:
                return True
            else:
                return False
        else:
            return False

    def clear(self, **kwargs) -> None:
        """Reinitializes the encoder state, preparing it for another :py:meth:`load` call.
        """
        if self.data is not None:
            del self.data
            del self.limit
            del self.index
            self.register_buffer('data', None)

    def load(
        self,
        inputs: torch.Tensor,
        step_time: float,
        num_steps: int,
        batch_dim: int | None = None
    ) -> None:
        """Loads data into encoder as a tensor of the expected frequencies of spikes.

        Args:
            inputs (torch.Tensor): tensor containing the expected frequency of spike events, in :math:`Hz`.
            step_time (float): length of the time steps as simulated for determining if a spike occurs during a step, in :math:`ms`.
            num_steps (int): the number of simulation time steps to execute for.
            batch_dim (int | None, optional): dimension of the input tensor which should be treated as the axis along the batch, if `None` this axis is created. Defaults to `None`.
        Raises:
            ValueError: Spike frequencies specified in `inputs` must all be non-negative frequencies, received a negative frequency.
        """
        # check that inputted rates are all non-negative
        if (inputs < 0).any():
            raise ValueError('all inputs must be non-negative frequencies in Hz, received a negative frequency')

        # clear existing state
        self.clear()

        # set data as empty tensor
        self.data = torch.empty_like(inputs, requires_grad=False)

        # set number of steps and step index
        self.limit = int(num_steps)
        self.index = 0

        # copy inputs into data
        self.data.copy_(inputs)

        # reshape data according to provided batch dimension
        if batch_dim is None:
            self.data.unsqueeze_(0)
        else:
            batch_dim = int(batch_dim) % len(tuple(self.data.shape))
            self.data = torch.movedim(self.data, batch_dim, 0)

        # convert given inputs (in hertz) to probability of a spike for one timestep
        # method of generation from https://www.cns.nyu.edu/~david/handouts/poisson.pdf
        # see also https://github.com/btel/python-in-neuroscience-tutorials/blob/master/poisson_process.ipynb
        self.data.div_(1000)
        self.data.mul_(step_time)

    def forward(self) -> torch.Tensor | None:
        """Generates spikes for next timestep, if ready.

        Returns:
            torch.Tensor | None: tensor of spikes for this timestep (if :py:attr:`ready` is `True`), otherwise `None`.
        """
        if self.ready:
            self.index += 1
            return torch.rand_like(self.data) < self.data
